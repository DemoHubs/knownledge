# 阻塞队列



## 概要

阻塞队列是支持阻塞插入、阻塞移除的队列。常用于生产者、消费者场景。

阻塞队列API提供如下4种方式：

![image-20191123133105182](https://tva1.sinaimg.cn/large/006y8mN6gy1g97wujz82kj31jg08u0z7.jpg)

- 抛出异常：
  - 当队列满时，往队列中插入元素会抛出异常
  - 当队列空时，往队列中获取元素会抛出异常
  - 方法如add、remove（出队并且删除元素，没有元素则抛出异常）、element
- 返回特殊值
  - 当往队列中插入元素，返回值表示是否插入成功，成功返回true
  - 当从队列获取元素，如果没有则返回null
  - 方法如：offer、poll（出队并且删除元素，没有元素则返回null）、peek（仅出队）
- 一直阻塞
  - 当队列满时，插入元素会一直阻塞，直到队列有空位
  - 当队列空时，获取元素会一直阻塞，直到队列不为空
  - 方法如：put、take
- 超时退出
  - 当队列满足，生产者线程尝试插入元素，会阻塞一段时间，如果超时了则生产者线程退出。

注意：如果是无界阻塞队列，队列永远不会出现满的情况，使用put或者offer方法永远不会被阻塞，而且使用offer方法永远返回true。





## Java阻塞队列

Java中提供了7个阻塞队列

- ArrayBlockingQueue：由数组结构组成的有界阻塞队列
- LinkedBlockingQueue：由链表结构阻塞的**有界**阻塞队列
- PriorityBlockingQueue：支持优先级排序的**无界**阻塞队列
- DelayQueue：延时队列，是无界阻塞队列，使用PriorityQueue实现
- SynchronousQueue：一个不存储元素的阻塞队列。但是存储线程
- LinkedTransferQueue：链表结构阻塞的无界阻塞队列
- LinkedBlockingDeque：链表组成的双向阻塞队列





## 接口

### Queue

Queue用来保存一组等待处理的元素，数据结构中的队列代码实现，**队列头部出队，队列尾部入队**。包含了几种实现：ConcurrentLinkedQueue、PriorityQueue。这是一个传统的先进先出队列。Queue上的操作不会阻塞，如果队列为空，将返回空值。Queue是由LinkedList实现的。



### BlockingQueue

BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。

如果队列为空，那么获取的操作将一直阻塞，直到队列中出现一个可以获取的元素。

如果队列已满（设置了有界队列），那么插入操作将一直阻塞，直到队列中有可用的空间。

常用在“生产者—消费者”设计模式中。







## 生产者—消费者设计模式

- 消除了生产者和消费者之间的代码依赖性。当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，从队列中获取数据。生产者不需要知道消费者的标识或数量，或者它们是否唯一的生产者，只需要将数据放入队列即可。同样，消费者也不需要知道生产者是谁，或者工作来自何处。
- 避免生产速率和消费速率不同的问题







## 实现原理



### Condition

使用Condition实现通知模式。

- 当队列空了，消费者线程会阻塞，生产者插入元素时，通过Condition通知消费者，也就是唤醒消费者线程，消费者线程来拿元素。
- 当队列满了，生产者线程会阻塞，消费者获取元素时，通过Condition通知生产者，也就是唤醒生产者线程，生产者线程继续插入元素。



### park

unsafe.park是个native方法，代码如下：

![image-20191123170120833](https://tva1.sinaimg.cn/large/006y8mN6gy1g982xbm5pyj30ze02aaa7.jpg)

park这个方法将会阻塞当前线程，只有以下4种情况中的一种放生时，该方法才会返回：

- 与park对应unpark已经执行 或者 执行。”已经执行“指的是unpark先执行，然后再执行park的情况。
- 线程被中断时
- 等待time参数的超时时间到了
- 异常现象发生时，这个异常现象没有任何原因（比如说系统奔溃了）