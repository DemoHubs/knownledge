# 问题



**如何用zk实现分布式锁**

假如有A、B两个客户端，如果A请求获取锁，那么A就会在Zookeeper上创建一个节点，即获取了锁。这时候B客户端请求获取锁会失败，然后B通过watcher监听该节点，当A释放锁的时候，把该节点删除，然后Zookeeper通过watch机制通知B，B再次尝试获取锁，获取成功。





**Zookeeper与redis分布式锁有和优缺点**

- redis分布式锁不适用于执行时间长的任务，否则可能出现超时问题。Zookeeper实现分布式锁没有这个问题。
- redis获取锁，需要实现为不断重试。而Zookeeper可以做到节点被删除了，通过watcher机制回调被阻塞的线程，从而继续执行业务，避免了轮询。
- 假如获取到锁的客户端挂了，redis方式的话，需要等到key过期，其他线程才能获取锁。而Zookeeper方式的话，客户端挂了，那么这个节点自动删除了，也就是自动释放锁。
- Redis分布式锁的性能更高，因为它不用处理数据的一致性。







**zookeeper选举，如果一直发起新的投票，投票是无法完成的，zookeeper怎么处理这种情况**

每个Zookeeper节点在检测到没有Leader，会发起投票，当完成当前投票前，不会发起新的一轮投票。假设极端情况下，每个Zookeeper节点都发起了一轮投票，那么抛弃当前轮次的投票，使用新一轮的投票 这种情况至多只会发生N次，N指的是Zookeeper集群中节点个数。因此，不会出现问题中死循环导致无法正常投票的情况。





**Zookeeper如何保持顺序一致性（原子性）**

又或者说，Zookeeper为什么可以做为分布式锁。

- 1、Zookeeper对每一个请求都生成ZXID，然后将请求放入到队列中，然后一条单独的线程从队列中拿出请求处理
- 2、如果是事务请求的话，就会进行投票
- 3、投票通过以后，将事务请求应用到内存数据库
- 4、将事务请求放入CommitProposal队列中，该队列用来保存最近提交的事务请求，以便集群机器进行数据的快速同步

正是将请求放到队列中顺序执行这个特性，让Zookeeper的请求执行具有顺序性，从而能实现分布式锁。

