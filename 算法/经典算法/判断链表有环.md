# 判断链表有环



## 问题

有一个单向链表，链表当中有可能出现“环”，就像下图这样。如何用程序判断出这个链表是有环链表？

![image-20200327160651458](https://tva1.sinaimg.cn/large/00831rSTgy1gd8jt7fpozj30gp0720uq.jpg)





## 方法一：

首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。

这个方法在流程上和方法一类似，本质的区别是使用了HashSet作为额外的缓存。

假设从链表头节点到入环点的距离是D，链表的环长是S。而每一次HashSet查找元素的时间复杂度是O(1), 所以总体的时间复杂度是1*(D+S)=D+S，可以简单理解为O(N)。而算法的空间复杂度还是D+S-1，可以简单地理解成O(N)。





## 方法二：

方法二在时间上面已经很优化了，有没有方法在空间上面也更加优化？

首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。

例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。

此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

![image-20200327160917478](https://tva1.sinaimg.cn/large/00831rSTgy1gd8jvow672j30b808c7a4.jpg)

假设从链表头节点到入环点的距离是D，链表的环长是S。那么循环会进行S次（为什么是S次，有心的同学可以自己揣摩下），可以简单理解为O（N）。除了两个指针以外，没有使用任何额外存储空间，所以空间复杂度是O（1）。





## 扩展

环形链表的问题还可以引申出更多问题，如下：



**问题一：**判断两个单向链表是否相交，如果相交，求出交点。

![image-20200327161039226](https://tva1.sinaimg.cn/large/00831rSTgy1gd8jx3tr7qj30h704ojsy.jpg)





**问题二：**在一个有环链表中，如何找出链表的入环点？

![image-20200327161058846](https://tva1.sinaimg.cn/large/00831rSTgy1gd8jxg3bgej30hf071di1.jpg)



**问题三：**单链表反转







## 参考

[判断链表有环](https://www.cnblogs.com/qingyunzong/p/9143321.html)

[链表反转](https://www.jianshu.com/p/d201e6a00e3f)

[链表相交](https://www.jianshu.com/p/634c147fe2a9)

