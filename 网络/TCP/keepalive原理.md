# keepalive原理

TCP 协议的设计者考虑到了这种检测长时间死连接的需求，于是乎设计了 keepalive 机制。Tcp keepalive指的是 **通过定时发送探测包来探测连接的对端是否存活，如果探测一定次数以后，客户端没有响应，服务端就会发送RST包断掉连接**，不过默认情况下需要 7200s 没有数据包交互才会发送 keepalive 探测包，往往这个时间太久了，我们熟知的很多组件都没有开启 keepalive 特性，而是选择在应用层做心跳机制。



## TCP 的 half open

网络故障或者系统宕机都将使得对端无法得知这个消息。如果应用程序不发送数据，可能永远无法得知该连接已经失效。假设应用程序是一个 web 服务器，客户端发出三次握手以后故障宕机活着被踢掉网线，对于 web 服务器而已，下一个数据包将永远无法到来，但是它一无所知。TCP 不会采用类似于轮询的方式来询问：小老弟你有什么东西要发给我吗？

这种情况下服务端会永远处于 ESTABLISHED 吗？

![image-20191004115421564](https://tva1.sinaimg.cn/large/006y8mN6gy1g7m12i3ry8j30sy0pon4w.jpg)

**上面所说的情况就是典型的 TCP「半打开 half open」**

这一个情况就是如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于半打开状态。 这种情况发现在通信的一方的主机崩溃、电源断掉的情况下。 只要不尝试通过半开连接来传输数据，正常工作的一端将不会检测出另外一端已经崩溃。





**为什么大部分应用程序都没有开启 keepalive 选项**

现在大部分应用程序（比如我们刚用的 nc）都没有开启 keepalive 选项，一个很大的原因就是默认的超时时间太长了，从没有数据交互到最终判断连接失效，需要花 2.1875 小时（7200 + 75 * 9），显然太长了。但如果修改这个值到比较小，又违背了 keepalive 的设计初衷（为了检查长时间死连接）



## http keep-alive与tcp keep-alive

http keep-alive与tcp keep-alive，不是同一回事，意图不一样。

http keep-alive是为了重用tcp连接，以便在同一个连接上传送多个http，提高socket的效率。

而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制