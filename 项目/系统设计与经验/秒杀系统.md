# 秒杀系统



## 背景

想要设计一个秒杀系统，首先要理解秒杀的场景，秒杀场景下面会产生哪些问题，怎么去解决这些问题。



### 场景

比如说双11抢购活动，有100台华为P30降价出售，那么接近0点的时候，大量用户疯狂刷新页面，点击购买。



### 问题

- 用户大量刷新页面，系统怎么抗压？
- 秒杀的时候，大量写入请求，系统怎么抗压？





## 方案



**用户大量刷新页面，系统怎么抗压？**

因为用户查询的是少量的商品数据，属于查询的热点数据，可以将这些商品数据提前加载到缓存中，采用缓存策略将请求尽量挡在上层的缓存中。

能被静态化的数据（比如商城里的图片和视频数据）尽量做到静态化，这样就可以命中 CDN 节点缓存减少 Web 服务器的查询量和带宽负担。

当然，你可以加上一些限流的策略，比如对短时间之内来自某一个用户、某一个 IP 或者某一台设备的重复请求做丢弃处理。





**秒杀的时候，大量写入请求，系统怎么抗压？**

大量写请求同时到达数据库，会造成数据库崩溃。为了避免这种情况的发送，我们使用消息队列，异步更新数据库数据。

消息队列既能支持解耦，也能保证高可用，还能平衡高速系统和低速系统处理任务的时间差。

其实你在一些组件中都会看到消息队列的影子：

- 在 Java 线程池中我们就会使用一个队列来暂时存储提交的任务，等待有空闲的线程处理这些任务；
- 操作系统中，中断的下半部分也会使用工作队列来实现延后执行；
- 我们在实现一个 RPC 框架时，也会将从网络上接收到的请求写到队列里，再启动若干个工作线程来处理。



我们的思路是：将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后，再处理其他请求。

我们会在后台启动若干个程序消费消息队列的消息，再执行校验库存、下单等逻辑。因为只有有限的消费者在消费，所以落到数据库上面的请求是有限的。而请求是可以在消息队列中短暂的堆积的，当库存被消耗完之后，消息队列中堆积的请求就可以被丢弃了。

![image-20200215173624033](https://tva1.sinaimg.cn/large/0082zybpgy1gbx7zp0m8mj30uk0awjuq.jpg)

这就是消息队列在秒杀系统中最主要的作用：消峰填谷（红包系统实际上也用到了一样的架构），也就是说它可以削平短暂的流量高峰。

虽说堆积会造成请求被短暂延迟处理，但是只要我们时刻监控消息队列中堆积的消息数量，当达到一定量时，增加消费者的数量，提高处理速度就好了。而且秒杀用户对于延迟知晓秒杀结果也是有一定容忍度的。

这里需要注意一下，我所说的是“短暂”延迟，如果长时间没有给用户公示秒杀结果，那么用户可能就会怀疑你的秒杀活动有猫腻了。所以在使用消息队列应对流量峰值时，需要对队列处理的时间、前端写入流量的大小、数据库处理能力做好评估，然后根据不同的量级来决定部署多少台队列处理程序。

比如你的秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到秒杀的结果，这是可以接受的。这时会并发 10 个请求到达数据库，并不会对数据库造成很大的压力。



## 总结

- 分布式缓存预加载商品数据
  - 通过缓存缓解读请求的压力
- 购买到商品的消息写入缓存，返回给前端购买成功
- 消息队列异步更新数据库（生成订单、更新库存）
  - 通过消息队列缓解写请求的压力
  - 这里消息队列实现了漏斗限流的算法，起到了消峰填谷的作用
- 数据库采用分库分表
- 上述是核心部分，其他的还有服务拆分，单个服务通过对机器（扩容）来提高性能







## 参考

[秒杀系统](https://time.geekbang.org/column/article/156904)

